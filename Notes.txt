Notes for Cloud Native Architecture Patterns


Agility  <--> Disruption

Fail fast, early and often and Fix fast, early and often

Waterscrumfall Consequences:

  - Slow Delivery
  - Large Batch sizes
  - Infrequent feedback
  - Increased waste

Go From MTBF and MTTR
Mean Time Between Failure to Mean Time To Recovery 

Scalability

Automated Recovery - why page someone ??

3 ways to dev ops 
(Phoenix Project, DevOps Handbook: How to create wordlcass agility, reliability, security)

1. Flow:

Dev  ---------> Ops
      (flow)

- concept to cash
- REDUCE BATCH SIZES !!



2. Feedback:

    <---------
Dev             Ops
    ---------> 
      (feedback)

3. Continual Learining / Experimentation:

     <---------
Dev  0  0  0  0    Ops
     ---------> 
    (iterative loops)




Technically support every source code commit to be deployable to production

3 key aspects:  
	 - Configuration Management
	 - Continuous Integration
	 - Automated Testing


	Continuous Delivery


         ------------------------------------------------------------------------
         -                                                                      -
         -      code     version control        config                  config  -  ---------
         -                                                                      -          |
         ------------------------------------------------------------------------          |
                 |                                |                                        |
                 |                                |                     --------           |
                 v                                v           |------>  - UAT  -   <-------|
            ----------                       --------------   |         --------           |
            - commit -                       - acceptance -   |          		   |
            - stage  -                       - stage      -   |         --------------     |
            ----------                       --------------   |------>  -Performance - <-- |
                |                                 ^           |         --------------     |
                |                                 |           |                            |
                |                                 |           |         ------------       |
                |                                 |           |------>  -Production-  <----|
                |                                 |           |         ------------       |
                v                                 |           | 
         ------------------------------------------------------------------------
         -                                                                      -
         -      Artifact Repository  JAR                                        -
         -                                                                      -
         ------------------------------------------------------------------------





##  Cloud Infrastructure 
## 

The Three Rs of Enterprise Security: Rotate, Repave, and Repair
https://builttoadapt.io/the-three-r-s-of-enterprise-security-rotate-repave-and-repair-f64f6d6ba29d


##  Service Models
## 


           [ SOFTWARE ]
         [  FUNCTIONS   ]
       [  P L A T F O R M   ]
     [  C O N T A I N E R S   ]
  [  I N F R A S T R U C T U R E  ]

The *aaS Pyramid


API Driven
	 - Automation
	 - Audit
	 - Authorization
	 - Accounting


Need speed, then create it
	Load balancers
	Databases
	Queues
	Storage Volumes
	Private Networks

Need to eliminate
	- ticket systems 
	- approval processes 
	- waiting queues
	- configuration errors


Elastic 
	- As demand increases we expand capacity by provisioning more resources
	- As demand decreaese we contract capacity by returning resources


What's Your Decompostion Strategy
https://builttoadapt.io/whats-your-decomposition-strategy-e19b8e72ac8f

	- Bounded contexts
	- Value Streams 
	- Single Responsibility Principle
	- Failure Domains
	- Anti-Corruption Layers

Modularity
	- Loose Coupling
	- High Cohesion
	- Encapsulation
	- Well-Defined interface


Microservices
	- modularity from code concept to lifecycle concept
	NOTE: If a microservice isn't giving you 3 ways, you probably don't need it.


Conway's Law:  Any organization that designs a system (defined broadly) will produce a design whose structure 
               is a copy of the organization's communication structure. 



## Observability: 
	- Need Feedback!!
	- See Failure When It Happens
	- Measure Everything


http://bravenewgeek.com/everything-you-know-about-latency-is-wrong



         [ Traceability ]                            [ Quantitative  ]
	  - git SHA                                  [ Measturements ]
	  - package coordinates 			- business metrics
	  - API version					- tech metrics
                  |                                           |	
                  |------------------|------------------------|
                         ---------------------
                         -                   -
                         -     service       -
                         -    Telemetry      -
                         -                   -
                         ---------------------
                  |------------------|------------------------|
                  |                                           |	

	[ Health ]				    [ Qualitative  ] 
	 - Me                                       [ Observations ]
	 - My Dependencies				- Logging
							- Exception Reporting





[ Deployability ]
	- Have you automated ALL of you deployment tasks ?
	- Can you transform a brand new deployment environment into you running architecture
          without manual work?
	- Can you vary configuration across environments without rebuilding code ?
	- Do you deploy like this everywhere ?
	- Can you do this without your users noticing ?

[ Testability ]
	- Have you automated ALL testing tasks that you possibly can ?
	- Do you have to deploy all the things to test anything ?
	- If testing is an experiment, can you control everything except you experimental variable ?
	- Can you run the same tests against any environment (including production) ?
	- Can you verify that you continue to meet your contractual obligations?

[ Disposability ]
	- Can I destroy a service instance at any time without consequence ?
	- Can I repave the entire architecture at any time without consequence ?
	- Can I respond to changes in demand by adding or removing instances of a service without consequence ?
	- Can I replace a sick service instance with a brand new copy without consequence?


[ Replacability ]
	- Can I route traffic to any available service instance without consequence ?
	- If I lose an AZ or Resion, can I route traffice to another without consequence ?
	- Can I swap between multiple implementations of the same service contract without consequence?
	- Can I swap between multiple running versions of a service without consequence?


[ Architectural Responsibilities ]
	- Architecture can make disposability impossible.
	- Architecture can make replaceability impossible
	- Architecture must take charge of removing the consequences of disposing and 
          replacing service instances 

"Cloud is less a place and more a way of doing things."

Fact: Amazon deploys once per second


DevOps Native Architecture

 	 [ Observability ]
	 [  Testability  ]

        <--------------------
          Disposability
  Dev    0  0  0  0  0  0     Ops
          Replacability
        --------------------> 

 	[  Modularity   ]
	[ Deployability ]

"Maps of your code"
https://c4model.com

   - context
   - containers
   - components
   - code

Architecture / design is the code !!




################################################################################
##
## Brick and Mortar Pattern Language
##
################################################################################

	- Context
		The basic current situation 
	- Problem
		Presents the problems as a system forces which must be balanced
	- Solution
		Describes the components that make up the general solution, how they relate to one another 
		and their runtime interactions



	Brick Patterns :  Patterns for constructing individual (micro)services
	Mortar Patterns:  Patterns for composing bricks into complete distributed systems



## Brick Patterns 
## 
	- Externalization Patterns: Structural patterns for creating deployable, disposable 
                                    and replaceable bricks
		- Externalized Configuration
		- Externalized State
		- Externalized Channels

	- Runtime Patterns: Behavioral patterns for creating deployable, replaceable 
                            and observable bricks
		- Runtime Reconfiguration
		- Concurrent Executions
		- Brick Telemetry



## Mortar Patterns 
## 
	- Distributed Systems Patterns: Composition patterns addressing common distributed system challenges
		- Service Discovery
		- Edge Gateway
		- Fault Tolerance

	- Integraion Patterns: Composition patterns addressing integrations and observability challenges
		- Event-Driven System
		- Contract Management 
		- Integration Telemetry





## Externalization Patterns > Externalized Configuration 
## 
	Context: Applications config will vary independently from its code throught its lifecycle
	Problem: Traditional techniques for manageing configuration tightly couple these two orthogonal concepts
	Forces:  Different env have different configs
			- resource handles to databse
			- credentials to external services
			- per deploy values: test vs. qa
			- features toggled on/off
			- Config often bundled with deployment artifacts
			- Build processes often modify configuration based on args
			- Deployment pipeline should only buyild each artifact once.


	Components: 
		- The Environment: Sources of configuration name/value pairs 
		- Environment Adapter: Component that understands a particular source of configuration
                                       and extracts anme/value pairs from it
		- Configuration Repository: Component that manages the aggregate configuration of the brick
		- Brick Component: Business component that is interested in configuration



## Environment Adapter
## 
	- Environment Variables
	- Start Command Arguments
	- Database
	- Configuration Service








## Externalization Patterns > Externalized State 
## 
	- Context: Disposability / Replaceability require elimination of "snowflake deployements"
	- Problem: Traditional state management techniques prevent us from achieving phoenix deployements
	- Forces : 
		- Early web architecture emphasized server state management
		- Statefule Scaffolding on Stateless Protocol (HTTP)
		- Cloud Infrastructure
			- Limited load balancer support
			- Limited support for persistence

	- Solution:
		- Single-Page Application
			- Persist to Local Storage
			- Persist completed work to database via HTTP 

		----------- 	   -----------	     -----------	
	        -         -	   -         -	     - service -	
	        - browser -  <->   -Stateless-	<->  - database-	
	        -         -	   -         -	     -         -	
                -----------	   -----------	     -----------	

		- Externalized Session 
			- interact with State manager

		----------- 	   -----------	     -----------	-----------	 -----------	
	        -         -	   -         -	     -  http   -	- session -	 -  dist   -	
	        - browser -  <->   -Stateless-	<->  - session -   <->  - state   -  <-> - cache   -	
	        -         -	   -         -	     -         -	- manager -	 -         -	
                -----------	   -----------	     -----------	-----------	 -----------	



## Externalization Patterns > Externalized Channels 
## 
	- Context: Want to be able to opportunistically evolve and recompose our systems 
                   as business drivers change 
	- Problem: Interleaving details of intercomponent communication w/ business logic makes
                   it difficult to leverage functions / data streams in unplanned ways
	- Forces:  Business processes and components are often reusable in other contexts
	           Business processes and components are independent of 
			- Wire protocol
			- Serialization Method
			- Fault Tolerance Aspects
	           Data streams can be trapped and redirected to other processes
	           Integration architectures are often "design onces, change never" ?
	           Business logic is often implemented in an integration architecture specific
                   framework scaffold.


Senneca.js : pattern matching
http://senecajs.org/



## Runtime Patterns > Runtime Reconfiguration 
## 
	- Context: Want to make configuration changes at runtime that are quick and
                   dont otherwise disturbe the state of the running system
	- Problem: Configuration changes are often coupled to deployment events.
	- Forces:  Configuration often happens only as a boot time evenet
		   Environment Vars only injected as part of a deployment event 
		   Debugging often implies "turning up the volume" on observability.
                      Sometimes we need a "pre-warmed" system to listen to.	
                   Decoupling feature releases from deployment through feature toggles
                      requires runtime config change
                   Rotating DB credentials should be faster than (and not require) 
                      the deployment pipeline.

	Solution: Config Server + Management Bus


		----------- 	   -----------	    
	        -         -	   -         -	   
	        - github  -  <->   -  Config -    ---------------------------------	
	        -         -	   -  Server -	                                  |
                -----------	   -----------	                                  |
                                ^       ^      ^                                  |
                               /        |       \                                 |
                              /         |        \                                |
                             /          |         \                               |
		----------- 	   -----------	     -----------	          |
	        -         -	   -         -	     -         -	          |
	        - brick a -  <->   - brick b -	<->  - brick c -	          |
	        -         -	   -         -	     -         -	          |
                -----------	   -----------	     -----------	          |
                            ^           ^          ^                              |
                             \          |         /                               |
                              \         |        /                                |
                               \        |       /                                 |
                                V       V      V                                  |
		           	  ----------------                                |
	                   	  -              -	                          |
	                          -  Management  -  <-------------------------------
	                   	  -     Bus      -
                           	  ----------------





## Runtime Patterns > Concurrent Exec
## 

	- Context: Users want features, not deployments.  Experiments often require concurrent
                   execution of multiple software versions.
	- Problem: Traditional techniques for managing deployments require downtime events
                   and don't support concurrent execution fo multiple software versions.
	- Forces : Feature releases are coupled to deployment events
                   Production deployments will often target a single infrastructure env
                   Failed deployments exacerbate downtime events.
                   Hypotheses validaton requires selective UX
                   Selective UX in a monolithic application is complex / error prone.

	- Solution:  Router + Service Registry


		----------- 	   -----------	     	   -----------	    
	        -         -	   -         -	   	   -         -	   
	        - Route   -  <->   -  Router -      <->    - Service -  <---------|  
	        - Manager -	   -         -	  	   - Registry-	          |
                -----------	   -----------	 	   -----------	          |  
                                ^              ^                                  |
                               /                \  Pool                           |
                        Pool  /                  \ Selection                      |
                  Selection  /                    \                               |
		------------ 	              	     ------------	          |
	        -          -	              	     -          -	          |
	        - brick v1 -                  	     - brick v2 -  ---------------|
	        -          -	              	     -          -	         
                ------------	          	     ------------	        
                                                                               
                           
                          
                         
                        

## Runtime Patterns > Brick Telemetry
## 
	- Context: Realizing the DevOps way of Feedback requires that we have visibility into
                   both the business value and the technical behavior generated by our services
	- Problem: Common approaches to service visibility fall short of architectural quality we need
	- Forces : Visiblity is often accomplished via post facto application of agent-based 
                   monitoring tools.
		   Agent-based monitoring tools don't understand business value
		   Determining an applications health often requires comples logic
		   Traceability of an application is difficult to accomplish w/ OTS solutions
	- Solutions: 
                     Traceability Components (/info)
			- git traceabiliity adapter            ---> git properties file
			- maven traceabiliity adapter          ---> maven properties file
			- api version traceabiliity adapter
			- feature toggle traceabiliity adapter ---> feature toggle framework

                     Health Components 
			- db health indicator                  ---> test db query
			- business compnent A health indicator ---> business component A 
			- disk space heal indicator 
			- business compnent B health indicator ---> business component A 

                     Metrics Components 
			- Metrics Registry 
			- Metrics Reporter 
			- Business Component A   -> Timer Metric Recorder
			- Business Component B   -> Histogram Metric Recorder
			- Business Component C   -> Gauge Metric Recorder



		----------- 	   -----------	     -----------	-----------
	        -         -	   -         -	     -         -	- trace   -
	        - client  -  <->   - trace   -	<->  - trace   -   <->  - info    -
	        -         -	   - endpoint-	     - adapter -	- source  -
                -----------	   -----------	     -----------	-----------
